<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>División a Mano Alzada</title>
    
    <!-- Estilos (Tailwind CSS) y Fuentes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&family=Inter:wght@400;700;900&family=Fira+Mono:wght@500;700&display=swap" rel="stylesheet">
    <style>
      body { font-family: 'Inter', sans-serif; touch-action: none; overscroll-behavior: none; }
      .math-font { font-family: 'Fira Mono', monospace; }
      /* Animaciones */
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      @keyframes zoomIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
      .animate-in { animation: fadeIn 0.2s ease-out forwards; }
      .zoom-in-95 { animation: zoomIn 0.2s ease-out forwards; }
    </style>

    <!-- ImportMap para dependencias (React, GenAI) -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "@google/genai": "https://esm.sh/@google/genai@1.34.0",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "vite": "https://esm.sh/vite@^7.3.0",
    "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@^5.1.2"
  }
}
</script>
    
    <!-- Babel para procesar JSX en el navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-white text-slate-900 h-[100dvh] overflow-hidden flex flex-col">
    <div id="root" class="h-full w-full flex flex-col"></div>

    <!-- Lógica de la Aplicación -->
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useCallback, useRef, forwardRef, useImperativeHandle } from 'react';
        import { createRoot } from 'react-dom/client';
        import { GoogleGenAI, Type } from '@google/genai';

        // ------------------------------------------------------------------
        // CONFIGURACIÓN API KEY
        // ------------------------------------------------------------------
        const API_KEY = "AIzaSyBHgc_I4g0IQOkZHAib0HHNoeUbqQwoHzU";
        
        // Configurar entorno para la librería
        window.process = { env: { API_KEY } };

        // ------------------------------------------------------------------
        // SERVICIO DE RECONOCIMIENTO (IA)
        // ------------------------------------------------------------------
        const recognizeHandwriting = async (base64Image) => {
          const ai = new GoogleGenAI({ apiKey: window.process.env.API_KEY });
          
          const prompt = `
            Analiza esta imagen de una operación de división matemática realizada a mano.
            Debes identificar el COCIENTE (quotient) y el RESTO (remainder) final que el usuario ha escrito.
            Retorna los valores en formato JSON.
            Si no puedes identificar alguno de los valores, pon null.
            Añade una breve explicación de lo que has visto.
          `;

          try {
            const response = await ai.models.generateContent({
              model: "gemini-3-flash-preview",
              contents: {
                parts: [
                  { text: prompt },
                  {
                    inlineData: {
                      mimeType: "image/png",
                      data: base64Image.split(',')[1],
                    },
                  },
                ],
              },
              config: {
                responseMimeType: "application/json",
                responseSchema: {
                  type: Type.OBJECT,
                  properties: {
                    quotient: { type: Type.NUMBER, nullable: true },
                    remainder: { type: Type.NUMBER, nullable: true },
                    explanation: { type: Type.STRING },
                  },
                  required: ["quotient", "remainder", "explanation"],
                },
              },
            });

            const resultText = response.text || "{}";
            return JSON.parse(resultText);
          } catch (error) {
            console.error("Error recognizing handwriting:", error);
            return {
              quotient: null,
              remainder: null,
              explanation: "Error al conectar con el servicio de reconocimiento."
            };
          }
        };

        // ------------------------------------------------------------------
        // COMPONENTE: DrawingCanvas (Lienzo)
        // ------------------------------------------------------------------
        const DrawingCanvas = forwardRef(({ gridSize = 40, mode }, ref) => {
          const canvasRef = useRef(null);
          const [isDrawing, setIsDrawing] = useState(false);
          const [lastPoint, setLastPoint] = useState(null);
          
          // Historial para Deshacer/Rehacer
          const [history, setHistory] = useState([]);
          const [redoStack, setRedoStack] = useState([]);

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const resizeCanvas = () => {
              const parent = canvas.parentElement;
              if (parent) {
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                let tempImage = null;
                if (canvas.width > 0 && canvas.height > 0) {
                   tempImage = ctx?.getImageData(0, 0, canvas.width, canvas.height) || null;
                }

                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                
                if (tempImage && ctx) {
                  ctx.putImageData(tempImage, 0, 0);
                } else if (history.length === 0) {
                  saveToHistory();
                }
              }
            };

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            return () => window.removeEventListener('resize', resizeCanvas);
          }, []);

          const saveToHistory = () => {
            const canvas = canvasRef.current;
            const ctx = canvas?.getContext('2d', { willReadFrequently: true });
            if (canvas && ctx) {
              const state = ctx.getImageData(0, 0, canvas.width, canvas.height);
              setHistory(prev => [...prev.slice(-19), state]);
              setRedoStack([]);
            }
          };

          const startDrawing = (e) => {
            setIsDrawing(true);
            const point = getPoint(e);
            setLastPoint(point);
          };

          const draw = (e) => {
            if (!isDrawing || !lastPoint) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas?.getContext('2d');
            if (!ctx) return;

            const currentPoint = getPoint(e);
            
            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (mode === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.lineWidth = 20;
            } else {
              ctx.globalCompositeOperation = 'source-over';
              ctx.strokeStyle = '#1e293b'; // slate-800
              ctx.lineWidth = 3;
            }
            
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(currentPoint.x, currentPoint.y);
            ctx.stroke();

            setLastPoint(currentPoint);
          };

          const stopDrawing = () => {
            if (isDrawing) {
              saveToHistory();
            }
            setIsDrawing(false);
            setLastPoint(null);
          };

          const getPoint = (e) => {
            const canvas = canvasRef.current;
            if (!canvas) return { x: 0, y: 0 };

            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            return {
              x: clientX - rect.left,
              y: clientY - rect.top,
            };
          };

          useImperativeHandle(ref, () => ({
            clear: () => {
              const canvas = canvasRef.current;
              const ctx = canvas?.getContext('2d');
              if (canvas && ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveToHistory();
              }
            },
            undo: () => {
              if (history.length <= 1) return;
              const canvas = canvasRef.current;
              const ctx = canvas?.getContext('2d');
              if (canvas && ctx) {
                const current = history[history.length - 1];
                const prev = history[history.length - 2];
                
                setRedoStack(stack => [...stack, current]);
                setHistory(prevStack => prevStack.slice(0, -1));
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.putImageData(prev, 0, 0);
              }
            },
            redo: () => {
              if (redoStack.length === 0) return;
              const canvas = canvasRef.current;
              const ctx = canvas?.getContext('2d');
              if (canvas && ctx) {
                const next = redoStack[redoStack.length - 1];
                
                setHistory(prev => [...prev, next]);
                setRedoStack(prev => prev.slice(0, -1));
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.putImageData(next, 0, 0);
              }
            },
            getSnapshot: () => {
              const canvas = canvasRef.current;
              if (!canvas) return '';
              
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = canvas.width;
              tempCanvas.height = canvas.height;
              const tCtx = tempCanvas.getContext('2d');
              if (tCtx) {
                tCtx.fillStyle = '#ffffff';
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tCtx.drawImage(canvas, 0, 0);
                return tempCanvas.toDataURL('image/png');
              }
              return canvas.toDataURL('image/png');
            }
          }));

          const gridStyle = {
            backgroundImage: `linear-gradient(to right, #e2e8f0 1px, transparent 1px), linear-gradient(to bottom, #e2e8f0 1px, transparent 1px)`,
            backgroundSize: `${gridSize}px ${gridSize}px`,
          };

          return (
            <canvas
              ref={canvasRef}
              onMouseDown={startDrawing}
              onMouseMove={draw}
              onMouseUp={stopDrawing}
              onMouseLeave={stopDrawing}
              onTouchStart={startDrawing}
              onTouchMove={draw}
              onTouchEnd={stopDrawing}
              style={gridStyle}
              className="w-full h-full cursor-crosshair touch-none bg-white transition-colors duration-200"
            />
          );
        });

        // ------------------------------------------------------------------
        // COMPONENTE: App (Principal)
        // ------------------------------------------------------------------
        const App = () => {
          const [problem, setProblem] = useState(null);
          const [isLoading, setIsLoading] = useState(false);
          const [showModal, setShowModal] = useState(false);
          const [feedback, setFeedback] = useState(null);
          const [aiAnalysis, setAiAnalysis] = useState(null);
          const [drawingMode, setDrawingMode] = useState('pencil');
          
          const canvasRef = useRef(null);

          const generateNewProblem = useCallback(() => {
            const dividend = Math.floor(100000 + Math.random() * 899999); // 6 cifras
            const divisor = Math.floor(100 + Math.random() * 899); // 3 cifras
            setProblem({ dividend, divisor });
            setFeedback(null);
            setAiAnalysis(null);
            setShowModal(false);
            canvasRef.current?.clear();
          }, []);

          useEffect(() => {
            generateNewProblem();
          }, [generateNewProblem]);

          const handleCheck = async () => {
            if (!problem || !canvasRef.current) return;

            setIsLoading(true);
            setFeedback(null);
            setAiAnalysis(null);

            try {
              const snapshot = canvasRef.current.getSnapshot();
              const result = await recognizeHandwriting(snapshot);
              setAiAnalysis(result);

              if (result.quotient === null || result.remainder === null) {
                setFeedback({ 
                  type: 'error', 
                  message: 'No se pudo identificar el cociente o el resto. Asegúrate de escribirlos claramente en tu resolución.' 
                });
              } else {
                const isValid = problem.dividend === (problem.divisor * result.quotient) + result.remainder;
                
                if (isValid) {
                  setFeedback({ 
                    type: 'success', 
                    message: '¡Excelente trabajo! La operación es totalmente correcta.' 
                  });
                } else {
                  setFeedback({ 
                    type: 'error', 
                    message: 'La operación no coincide. Revisa tus cálculos y asegúrate de que el resto sea menor que el divisor.' 
                  });
                }
              }
              setShowModal(true);
            } catch (err) {
              setFeedback({ type: 'error', message: 'Ocurrió un error al procesar el dibujo. Verifica tu conexión.' });
              setShowModal(true);
            } finally {
              setIsLoading(false);
            }
          };

          return (
            <div className="flex flex-col h-screen max-h-screen bg-white overflow-hidden font-sans">
              {/* Navbar Superior */}
              <nav className="bg-white border-b border-slate-200 px-4 md:px-6 py-3 flex items-center justify-between gap-2 z-10 shadow-sm">
                <div className="flex items-center gap-2 md:gap-3">
                  <div className="bg-blue-600 p-1.5 md:p-2 rounded-lg text-white">
                    <svg className="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                  </div>
                  <h1 className="text-lg md:text-xl font-bold text-slate-800 hidden xs:block">División a Mano</h1>
                </div>

                <div className="flex items-center bg-slate-50 p-1 rounded-xl border border-slate-200 shadow-inner">
                  <button 
                    onClick={() => setDrawingMode('pencil')}
                    className={`p-1.5 md:p-2 rounded-lg transition-all ${drawingMode === 'pencil' ? 'bg-white shadow-md text-blue-600' : 'text-slate-400 hover:text-slate-600'}`}
                    title="Lápiz"
                  >
                    <svg className="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>
                  </button>
                  <button 
                    onClick={() => setDrawingMode('eraser')}
                    className={`p-1.5 md:p-2 rounded-lg transition-all ${drawingMode === 'eraser' ? 'bg-white shadow-md text-red-600' : 'text-slate-400 hover:text-slate-600'}`}
                    title="Borrador"
                  >
                    <svg className="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                  </button>
                  <div className="w-px h-5 md:h-6 bg-slate-200 mx-1"></div>
                  <button onClick={() => canvasRef.current?.undo()} className="p-1.5 md:p-2 text-slate-400 hover:text-slate-600" title="Deshacer"><svg className="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg></button>
                  <button onClick={() => canvasRef.current?.redo()} className="p-1.5 md:p-2 text-slate-400 hover:text-slate-600" title="Rehacer"><svg className="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 10h-10a8 8 0 00-8 8v2m18-10l-6 6m6-6l-6-6" /></svg></button>
                </div>

                <div className="flex gap-2">
                  <button onClick={generateNewProblem} className="hidden sm:flex px-3 md:px-4 py-2 bg-white text-slate-600 font-semibold rounded-lg border border-slate-200 hover:bg-slate-50 transition-all text-sm md:text-base">Nueva</button>
                  <button onClick={handleCheck} disabled={isLoading} className={`px-4 md:px-6 py-2 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition-all text-sm md:text-base ${isLoading ? 'opacity-50' : ''}`}>
                    {isLoading ? 'Analizando...' : 'Comprobar'}
                  </button>
                </div>
              </nav>

              {/* Área Principal del Lienzo */}
              <main className="flex-1 relative overflow-hidden">
                <div className="w-full h-full relative">
                  {/* Overlay del Problema - Sin fondo blanco/rectángulo externo */}
                  {problem && (
                    <div className="absolute top-8 md:top-12 left-0 right-0 z-10 flex justify-center items-start pointer-events-none select-none px-4">
                      <div className="flex items-start max-w-full">
                        {/* Dividendo */}
                        <div className="pr-4 md:pr-12 pt-2">
                          <span 
                            className="text-4xl sm:text-6xl md:text-8xl font-mono font-black text-slate-800 whitespace-nowrap block" 
                            style={{ letterSpacing: '0.3em', marginRight: '-0.3em' }}
                          >
                            {problem.dividend}
                          </span>
                        </div>
                        
                        {/* Divisor con la "L" característica de la división */}
                        <div className="flex-shrink-0 border-l-4 md:border-l-8 border-b-4 md:border-b-8 border-slate-800 pl-4 md:pl-10 pb-2 md:pb-6 pr-2 md:pr-6 pt-2">
                          <span 
                            className="text-4xl sm:text-6xl md:text-8xl font-mono font-black text-slate-800 whitespace-nowrap block"
                            style={{ letterSpacing: '0.2em', marginRight: '-0.2em' }}
                          >
                            {problem.divisor}
                          </span>
                        </div>
                      </div>
                    </div>
                  )}

                  <DrawingCanvas ref={canvasRef} mode={drawingMode} />
                </div>
              </main>

              {/* Modal de Resultados */}
              {showModal && (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-in zoom-in-95">
                  <div className="bg-white w-full max-w-lg rounded-[2.5rem] shadow-2xl overflow-hidden">
                    <div className={`p-6 md:p-8 text-center ${feedback?.type === 'success' ? 'bg-green-50' : 'bg-red-50'}`}>
                      <div className={`mx-auto w-14 h-14 md:w-16 md:h-16 rounded-full flex items-center justify-center mb-4 ${feedback?.type === 'success' ? 'bg-green-100 text-green-600' : 'bg-red-100 text-red-600'}`}>
                        {feedback?.type === 'success' ? (
                          <svg className="w-8 h-8 md:w-10 md:h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7" /></svg>
                        ) : (
                          <svg className="w-8 h-8 md:w-10 md:h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M6 18L18 6M6 6l12 12" /></svg>
                        )}
                      </div>
                      <h2 className={`text-2xl md:text-3xl font-black mb-2 ${feedback?.type === 'success' ? 'text-green-800' : 'text-red-800'}`}>
                        {feedback?.type === 'success' ? '¡Excelente!' : '¡Oops! Revisa'}
                      </h2>
                      <p className="text-slate-600 font-medium px-4 text-sm md:text-base">{feedback?.message}</p>
                    </div>

                    <div className="p-6 md:p-8">
                      {aiAnalysis && (
                        <div className="bg-slate-50 rounded-3xl p-4 md:p-6 border border-slate-100 mb-6 md:mb-8">
                          <div className="flex justify-around items-center">
                            <div className="text-center">
                              <span className="block text-[10px] md:text-xs text-slate-400 font-bold uppercase mb-1 tracking-tighter">Cociente detectado</span>
                              <span className="text-3xl md:text-4xl font-mono font-black text-slate-700">{aiAnalysis.quotient ?? '?'}</span>
                            </div>
                            <div className="w-px h-10 md:h-12 bg-slate-200"></div>
                            <div className="text-center">
                              <span className="block text-[10px] md:text-xs text-slate-400 font-bold uppercase mb-1 tracking-tighter">Resto detectado</span>
                              <span className="text-3xl md:text-4xl font-mono font-black text-slate-700">{aiAnalysis.remainder ?? '?'}</span>
                            </div>
                          </div>
                        </div>
                      )}
                      <div className="flex flex-col gap-3">
                        <button onClick={() => setShowModal(false)} className="w-full py-3 md:py-4 bg-slate-800 text-white font-bold rounded-2xl hover:bg-slate-900 transition-colors text-sm md:text-base">Corregir mi dibujo</button>
                        <button onClick={generateNewProblem} className="w-full py-3 md:py-4 bg-blue-600 text-white font-bold rounded-2xl shadow-lg hover:bg-blue-700 transition-colors text-sm md:text-base">Nueva división</button>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        };

        // Renderizado
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
